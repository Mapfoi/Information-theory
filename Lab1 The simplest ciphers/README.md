## Общая структура программы

Программа реализована как WinForms‑приложение (`WinExe`). Точка входа:

- **`Program.Main`**  
  - Инициализирует конфигурацию приложения (`ApplicationConfiguration.Initialize()`).
  - Создаёт и показывает основную форму: `Application.Run(new Form1());`.

Основная логика работы сосредоточена в классе **`Form1`**.

## Основные элементы интерфейса

- **Переключатели алгоритма**
  - `radioButton1` — метод децимации (английский текст).
  - `radioButton2` — шифр Виженера с прямым ключом (русский текст).
- **Поля ввода**
  - `textBox_Key` — ключ шифрования/дешифрования.
  - `textBox_Plaintext` — исходный текст или текст для расшифрования (с клавиатуры или из файла).
  - `textBox_Cyphertext` — результат шифрования/дешифрования.
- **Файловые операции**
  - `button_ReadFromFile` — считывание исходного текста из файла.
  - `checkBox_SaveToFile` — флаг: сохранять ли результат в файл.
- **Кнопки действий**
  - `button_Encode` — зашифровать.
  - `button_Decode` — расшифровать.
  - `button_Clear` — очистить все текстовые поля и ключ.

## Порядок вызова функций при шифровании

1. Пользователь выбирает алгоритм (`radioButton1` или `radioButton2`), вводит текст и ключ.  
2. Нажимает **«Зашифровать»** → вызывается обработчик:
   - **`Form1.button_Encode_Click`**
3. Внутри `button_Encode_Click`:
   - Считываются `plaintext` и `key` из `textBox_Plaintext` и `textBox_Key`.
   - Проверяется, что оба поля не пустые (иначе выводится сообщение об ошибке и выполнение прерывается).
   - В зависимости от выбранного алгоритма:
     - Если `radioButton1.Checked`:
       - вызывается **`EncryptDecimation(plaintext, key)`**;
     - Если `radioButton2.Checked`:
       - вызывается **`EncryptVigenereRussian(plaintext, key)`**.
   - Результат записывается в `textBox_Cyphertext`.
   - Если установлен `checkBox_SaveToFile.Checked == true`:
     - вызывается **`SaveResultToFile(result)`** (диалог выбора файла и запись результата).

## Порядок вызова функций при расшифровании

1. Пользователь выбирает алгоритм, вводит зашифрованный текст (в `textBox_Plaintext`) и ключ.  
2. Нажимает **«Расшифровать»** → вызывается обработчик:
   - **`Form1.button_Decode_Click`**
3. Внутри `button_Decode_Click`:
   - Считываются `ciphertext` и `key`.
   - Проверяется, что поля не пустые.
   - В зависимости от выбранного алгоритма:
     - Если `radioButton1.Checked`:
       - вызывается **`DecryptDecimation(ciphertext, key)`**;
     - Если `radioButton2.Checked`:
       - вызывается **`DecryptVigenereRussian(ciphertext, key)`**.
   - Результат записывается в `textBox_Cyphertext`.
   - При установленном `checkBox_SaveToFile` вызывается **`SaveResultToFile(result)`**.

## Работа с файлами

- **Чтение исходного текста из файла**
  - Обработчик: **`button_ReadFromFile_Click`**.
  - Действия:
    - Открывается `OpenFileDialog` с фильтром `*.txt`.
    - Выбранный файл считывается целиком в кодировке UTF‑8:
      - `File.ReadAllText(openDialog.FileName, Encoding.UTF8)`.
    - Содержимое записывается в `textBox_Plaintext`.

- **Сохранение результата в файл**
  - Метод: **`SaveResultToFile(string result)`**.
  - Вызов осуществляется только если `checkBox_SaveToFile.Checked == true`.
  - Действия:
    - Открывается `SaveFileDialog` с фильтром `*.txt`.
    - При подтверждении диалога результат записывается в выбранный файл:
      - `File.WriteAllText(saveDialog.FileName, result, Encoding.UTF8)`.

## Реализация метода децимации (английский текст)

- **Алфавит**
  - Используется только латинский алфавит:
    - `EnglishAlphabetUpper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"`
    - `EnglishAlphabetLower = "abcdefghijklmnopqrstuvwxyz"`
  - Длина алфавита \( m = 26 \).

- **Ключ**
  - Вводится пользователем в `textBox_Key` в **любом формате**.
  - Из строки ключа извлекаются **только цифры**; все остальные символы (буквы, знаки и т.п.) игнорируются.
  - Пример: `"32ASd1фыв"` → `"321"` → ключ **321**.
  - Проверяется условие:
    - \( k > 0 \) и `Gcd(k, 26) == 1` — ключ должен быть **взаимно простым** с длиной алфавита, иначе обратный элемент не существует.

- **Вспомогательные функции**
  - **`Gcd(int a, int b)`** — вычисляет НОД по алгоритму Евклида.
  - **`ModInverse(int a, int m)`** — ищет мультипликативно обратный элемент \( a^{-1} \mod m \) перебором:
    - находит такое `x`, что `(a * x) % m == 1`.

- **Шифрование: `EncryptDecimation(string text, string keyString)`**
  - Для каждого символа `ch`:
    - Если `ch` — латинская буква (`A–Z` или `a–z`):
      - символ приводится к верхнему регистру, находится индекс `idx` в `EnglishAlphabetUpper`.
      - вычисляется новый индекс:
        - \[ newIdx = (k * idx) mod 26 \]
      - в результат записывается **заглавная** буква `EnglishAlphabetUpper[newIdx]`.
    - Если символ не является латинской буквой:
      - **пропускается** (не записывается в результат).

- **Дешифрование: `DecryptDecimation(string text, string keyString)`**
  - Разбирает ключ (извлечение цифр) и проверяет условия.
  - Вычисляет **обратный ключ**:
    - `int inv = ModInverse(k, 26);`
  - Для каждой латинской буквы:
    - символ приводится к верхнему регистру, находится индекс `idx` в алфавите.
    - вычисляется:
      - \[ newIdx = (inv * idx) mod 26 \]
    - в результат записывается **заглавная** буква `EnglishAlphabetUpper[newIdx]`.
  - Все не‑латинские символы **пропускаются** (не попадают в результат).

## Реализация шифра Виженера (русский текст)

- **Алфавит**
  - Используется русский алфавит **с буквой `Ё`**:
    - `RussianAlphabetUpper = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"`
    - `RussianAlphabetLower = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"`
  - Длина алфавита \( m = 33 \).

- **Предобработка ключа: `BuildRussianKeyShifts(string key)`**
  - Ключ можно вводить в **любом формате**.
  - Для каждого символа ключа:
    - Если это русская буква (любой регистр) — берётся её индекс в алфавите (символ приводится к верхнему регистру).
    - Любые **не‑русские символы в ключе игнорируются** (буквы других алфавитов, цифры, знаки).
  - Собирается список целых `shifts`, каждый элемент — сдвиг по алфавиту (0…32).
  - Если после фильтрации список пуст — выбрасывается ошибка: ключ должен содержать хотя бы одну русскую букву.

- **Шифрование: `EncryptVigenereRussian(string text, string key)`**
  - Получает массив сдвигов: `keyShifts = BuildRussianKeyShifts(key)`.
  - Перебирает символы исходного текста:
    - Если символ — русская буква (любой регистр):
      - приводится к верхнему регистру, находится индекс `idx` в `RussianAlphabetUpper`.
      - берётся текущий сдвиг `shift = keyShifts[keyPos % keyShifts.Length]`.
      - вычисляется новый индекс:
        - \[ newIdx = (idx + shift) mod 33 \]
      - в результат записывается **заглавная** буква `RussianAlphabetUpper[newIdx]`.
      - `keyPos` увеличивается на 1 (ключ повторяется по буквам русского текста).
    - Если символ **не русская буква**:
      - **пропускается** (не записывается в результат).

- **Дешифрование: `DecryptVigenereRussian(string text, string key)`**
  - Аналогично шифрованию:
    - `keyShifts = BuildRussianKeyShifts(key)`.
    - Для каждой русской буквы:
      - символ приводится к верхнему регистру, находится `idx` в алфавите.
      - вычисляется:
        - \[ newIdx = (idx - shift) mod 33 \]
      - при отрицательном результате `newIdx` корректируется:
        - `if (newIdx < 0) newIdx += RussianAlphabetUpper.Length;`
      - в результат записывается **заглавная** буква `RussianAlphabetUpper[newIdx]`.
    - Все не‑русские символы **пропускаются** (не попадают в результат).

## Обработка символов вне алфавита и регистр

- **Ввод** (текст и ключ) можно вводить в **любом регистре** и с любыми символами.
- **Вывод** всегда в **верхнем регистре** (заглавные буквы).

Для обоих алгоритмов:

- **Метод децимации**:
  - Шифруются **только латинские буквы** `A–Z` и `a–z`.
  - Все остальные символы (кириллица, цифры, пробелы, знаки препинания и т.д.) **пропускаются** и **не записываются** в результат.

- **Шифр Виженера**:
  - Шифруются **только русские буквы** (включая `Ё`/`ё`).
  - Любые иные символы (латиница, цифры, пробелы, пунктуация) **пропускаются** и **не записываются** в результат.

