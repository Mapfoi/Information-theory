## Общая структура программы

Программа реализована как WinForms‑приложение (`WinExe`). Точка входа:

- **`Program.Main`**  
  - Инициализирует конфигурацию приложения (`ApplicationConfiguration.Initialize()`).
  - Создаёт и показывает основную форму: `Application.Run(new Form1());`.

Основная логика работы сосредоточена в классе **`Form1`**.

## Основные элементы интерфейса

- **Переключатели алгоритма**
  - `radioButton1` — метод децимации (английский текст).
  - `radioButton2` — шифр Виженера с прямым ключом (русский текст).
- **Поля ввода**
  - `textBox_Key` — ключ шифрования/дешифрования.
  - `textBox_Plaintext` — исходный текст или текст для расшифрования (с клавиатуры или из файла).
  - `textBox_Cyphertext` — результат шифрования/дешифрования.
- **Файловые операции**
  - `button_ReadFromFile` — считывание исходного текста из файла.
  - `checkBox_SaveToFile` — флаг: сохранять ли результат в файл.
- **Кнопки действий**
  - `button_Encode` — зашифровать.
  - `button_Decode` — расшифровать.
  - `button_Clear` — очистить все текстовые поля и ключ.

## Порядок вызова функций при шифровании

1. Пользователь выбирает алгоритм (`radioButton1` или `radioButton2`), вводит текст и ключ.  
2. Нажимает **«Зашифровать»** → вызывается обработчик:
   - **`Form1.button_Encode_Click`**
3. Внутри `button_Encode_Click`:
   - Считываются `plaintext` и `key` из `textBox_Plaintext` и `textBox_Key`.
   - Проверяется, что оба поля не пустые (иначе выводится сообщение об ошибке и выполнение прерывается).
   - В зависимости от выбранного алгоритма:
     - Если `radioButton1.Checked`:
       - вызывается **`EncryptDecimation(plaintext, key)`**;
     - Если `radioButton2.Checked`:
       - вызывается **`EncryptVigenereRussian(plaintext, key)`**.
   - Результат записывается в `textBox_Cyphertext`.
   - Если установлен `checkBox_SaveToFile.Checked == true`:
     - вызывается **`SaveResultToFile(result)`** (диалог выбора файла и запись результата).

## Порядок вызова функций при расшифровании

1. Пользователь выбирает алгоритм, вводит зашифрованный текст (в `textBox_Plaintext`) и ключ.  
2. Нажимает **«Расшифровать»** → вызывается обработчик:
   - **`Form1.button_Decode_Click`**
3. Внутри `button_Decode_Click`:
   - Считываются `ciphertext` и `key`.
   - Проверяется, что поля не пустые.
   - В зависимости от выбранного алгоритма:
     - Если `radioButton1.Checked`:
       - вызывается **`DecryptDecimation(ciphertext, key)`**;
     - Если `radioButton2.Checked`:
       - вызывается **`DecryptVigenereRussian(ciphertext, key)`**.
   - Результат записывается в `textBox_Cyphertext`.
   - При установленном `checkBox_SaveToFile` вызывается **`SaveResultToFile(result)`**.

## Работа с файлами

- **Чтение исходного текста из файла**
  - Обработчик: **`button_ReadFromFile_Click`**.
  - Действия:
    - Открывается `OpenFileDialog` с фильтром `*.txt`.
    - Выбранный файл считывается целиком в кодировке UTF‑8:
      - `File.ReadAllText(openDialog.FileName, Encoding.UTF8)`.
    - Содержимое записывается в `textBox_Plaintext`.

- **Сохранение результата в файл**
  - Метод: **`SaveResultToFile(string result)`**.
  - Вызов осуществляется только если `checkBox_SaveToFile.Checked == true`.
  - Действия:
    - Открывается `SaveFileDialog` с фильтром `*.txt`.
    - При подтверждении диалога результат записывается в выбранный файл:
      - `File.WriteAllText(saveDialog.FileName, result, Encoding.UTF8)`.

## Реализация метода децимации (английский текст)

- **Алфавит**
  - Используется только латинский алфавит:
    - `EnglishAlphabetUpper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"`
    - `EnglishAlphabetLower = "abcdefghijklmnopqrstuvwxyz"`
  - Длина алфавита \( m = 26 \).

- **Ключ**
  - Вводится пользователем как **целое число** в `textBox_Key`.
  - Разбирается в методах `EncryptDecimation` / `DecryptDecimation`.
  - Проверяется условие:
    - \( k > 0 \) и `Gcd(k, 26) == 1` — ключ должен быть **взаимно простым** с длиной алфавита, иначе обратный элемент не существует.

- **Вспомогательные функции**
  - **`Gcd(int a, int b)`** — вычисляет НОД по алгоритму Евклида.
  - **`ModInverse(int a, int m)`** — ищет мультипликативно обратный элемент \( a^{-1} \mod m \) перебором:
    - находит такое `x`, что `(a * x) % m == 1`.

- **Шифрование: `EncryptDecimation(string text, string keyString)`**
  - Для каждого символа `ch`:
    - Если `ch` — латинская буква (`A–Z` или `a–z`):
      - определяется регистр (`isUpper`).
      - находится индекс `idx` буквы в `EnglishAlphabetUpper` или `EnglishAlphabetLower`.
      - вычисляется новый индекс:
        - \[ newIdx = (k * idx) mod 26 \]
      - выбирается зашифрованный символ из соответствующего алфавита по `newIdx`.
    - Если символ не является латинской буквой:
      - **копируется без изменений** (символы других алфавитов, пробелы, знаки препинания и т.п.).

- **Дешифрование: `DecryptDecimation(string text, string keyString)`**
  - Также разбирает ключ и проверяет условия.
  - Вычисляет **обратный ключ**:
    - `int inv = ModInverse(k, 26);`
  - Для каждой латинской буквы:
    - находится индекс `idx` в алфавите.
    - вычисляется:
      - \[ newIdx = (inv * idx) mod 26 \]
    - по `newIdx` выбирается исходная буква (в нужном регистре).
  - Все не‑латинские символы **не изменяются**.

## Реализация шифра Виженера (русский текст)

- **Алфавит**
  - Используется русский алфавит **с буквой `Ё`**:
    - `RussianAlphabetUpper = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"`
    - `RussianAlphabetLower = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"`
  - Длина алфавита \( m = 33 \).

- **Предобработка ключа: `BuildRussianKeyShifts(string key)`**
  - Проверяется, что ключ не пустой.
  - Для каждого символа ключа:
    - Если это русская буква верхнего регистра — берётся индекс в `RussianAlphabetUpper`.
    - Если это русская буква нижнего регистра — индекс в `RussianAlphabetLower`.
    - Любые **не‑русские символы в ключе игнорируются**.
  - Собирается список целых `shifts`, каждый элемент — сдвиг по алфавиту (0…32).
  - Если после фильтрации список пуст — выбрасывается ошибка: ключ должен содержать хотя бы одну русскую букву.

- **Шифрование: `EncryptVigenereRussian(string text, string key)`**
  - Получает массив сдвигов: `keyShifts = BuildRussianKeyShifts(key)`.
  - Перебирает символы исходного текста:
    - Если символ — русская заглавная буква:
      - находит индекс `idx` в `RussianAlphabetUpper`, помечает `isUpper = true`.
    - Если символ — русская строчная буква:
      - индекс `idx` в `RussianAlphabetLower`, `isUpper = false`.
    - Если символ **не русская буква**:
      - **копируется без изменений**.
    - Для русских букв:
      - берётся текущий сдвиг `shift = keyShifts[keyPos % keyShifts.Length]`.
      - вычисляется новый индекс:
        - \[ newIdx = (idx + shift) mod 33 \]
      - выбирается зашифрованный символ:
        - из `RussianAlphabetUpper` или `RussianAlphabetLower` в зависимости от регистра.
      - `keyPos` увеличивается на 1 (ключ повторяется по буквам русского текста).

- **Дешифрование: `DecryptVigenereRussian(string text, string key)`**
  - Аналогично шифрованию:
    - `keyShifts = BuildRussianKeyShifts(key)`.
    - Для каждой русской буквы:
      - находится `idx` в алфавите.
      - вычисляется:
        - \[ newIdx = (idx - shift) mod 33 \]
      - при отрицательном результате `newIdx` корректируется:
        - `if (newIdx < 0) newIdx += RussianAlphabetUpper.Length;`
      - по `newIdx` выбирается исходная буква нужного регистра.
    - Все не‑русские символы **копируются как есть**.

## Игнорирование символов вне алфавита

Для обоих алгоритмов выполняется одинаковый принцип:

- **Метод децимации**:
  - Шифруются **только латинские буквы** `A–Z` и `a–z`.
  - Все остальные символы (кириллица, цифры, пробелы, знаки препинания и т.д.) **переносятся в выходной текст без изменений**.

- **Шифр Виженера**:
  - Шифруются **только русские буквы** (включая `Ё`/`ё`).
  - Любые иные символы (латиница, цифры, пробелы, пунктуация) **не изменяются**.

